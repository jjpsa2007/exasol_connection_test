import { SQLQueriesResponse, SQLResponse } from './types';
import { CommandsNoResult, Attributes, Commands } from './commands';
import { QueryResult } from './query-result';
export type Cancelable = () => void;
export type CetCancelFunction = (cancel?: Cancelable) => void;
export interface IExasolDriver {
    /**
     * Connect to database
     *
     * @async
     * @reject {Error}
     * @returns {Promise.<void>}
     */
    connect(): Promise<void>;
    /**
     * Cancel the last active job
     */
    cancel(): Promise<void>;
    /**
     *  Close current connection
     */
    close(): Promise<void>;
    /**
     * Query single SQL statement
     *
     * @async
     * @param {string} sqlStatement
     * @param {Partial<Attributes>} attributes
     * @reject {Error}
     * @returns {Promise.<SQLResponse<SQLQueriesResponse>>}
     */
    query(sqlStatement: string, attributes?: Partial<Attributes>, getCancel?: CetCancelFunction): Promise<QueryResult>;
    query(sqlStatement: string, attributes?: Partial<Attributes>, getCancel?: CetCancelFunction, responseType?: 'default'): Promise<QueryResult>;
    /**
     * Query single SQL statement and get raw result
     *
     * @async
     * @param {string} sqlStatement
     * @param {Partial<Attributes>} attributes
     * @reject {Error}
     * @returns {Promise.<SQLResponse<SQLQueriesResponse>>}
     */
    query(sqlStatement: string, attributes?: Partial<Attributes>, getCancel?: CetCancelFunction, responseType?: 'raw'): Promise<SQLResponse<SQLQueriesResponse>>;
    /**
     * Execute single SQL statement
     *
     * @async
     * @param {string} sqlStatement
     * @param {Partial<Attributes>} attributes
     * @reject {Error}
     * @returns {Promise.<number>}
     */
    execute(sqlStatement: string, attributes?: Partial<Attributes>, getCancel?: CetCancelFunction): Promise<number>;
    execute(sqlStatement: string, attributes?: Partial<Attributes>, getCancel?: CetCancelFunction, responseType?: 'default'): Promise<number>;
    /**
     * Execute single SQL statement and get raw result back
     *
     * @async
     * @param {string} sqlStatement
     * @param {Partial<Attributes>} attributes
     * @reject {Error}
     * @returns {Promise.<SQLResponse<SQLQueriesResponse>>}
     */
    execute(sqlStatement: string, attributes?: Partial<Attributes>, getCancel?: CetCancelFunction, responseType?: 'raw'): Promise<SQLResponse<SQLQueriesResponse>>;
    /**
     * Executes multiple SQL statements sequentially as a batch.
     *
     * @async
     * @param {string[]} sqlStatements - Array of sql statements
     * @param {Partial<Attributes>} attributes
     * @reject {Error}
     * @returns {Promise.<SQLResponse<SQLQueriesResponse>>}
     */
    executeBatch(sqlStatements: string[], attributes?: Partial<Attributes>, getCancel?: CetCancelFunction): Promise<SQLResponse<SQLQueriesResponse>>;
    /**
     * Prepare statement
     *
     * @async
     * @param  {string} sqlStatement
     * @reject {Error}
     * @returns {Promise.<IStatement>}
     */
    prepare(sqlStatement: string): Promise<IStatement>;
    /**
     * Send commands which have no results
     * @param {CommandsNoResult} cmd
     */
    sendCommandWithNoResult(cmd: CommandsNoResult): Promise<void>;
    /**
     * Send commands and wait for result, while a command is executed all other commands will be rejected till the current command finished.
     * @async
     * @param  {Commands} cmd
     * @reject {Error}
     * @template T
     * @returns {Promise.<SQLResponse<T>>}
     */
    sendCommand<T>(cmd: Commands): Promise<SQLResponse<T>>;
}
export interface IStatement {
    /**
     * Close statement
     */
    close(): Promise<void>;
    /**
     *  Execute prepared statement with given args
     *
     * @async
     * @param {...any} args
     * @reject {Error}
     * @returns {Promise.<SQLResponse<SQLQueriesResponse>>}
     */
    execute(...args: Array<unknown>): Promise<SQLResponse<SQLQueriesResponse>>;
}
